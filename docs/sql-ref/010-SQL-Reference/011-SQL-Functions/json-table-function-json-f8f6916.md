<!-- loiof8f6916b5c434a6fbd1bb7e0dc65acd4 -->

# JSON\_TABLE Function \(JSON\)

Queries a JSON text and presents it as a relational table.



<a name="loiof8f6916b5c434a6fbd1bb7e0dc65acd4__json_table_function_1sql_json_table_function"/>

## Syntax

```
JSON_TABLE(
 <JSON_API_common_syntax>
 <JSON_table_columns_clause>
 [ <JSON_table_error_behavior> ON ERROR ]
 )
```



## Syntax Elements


<dl>
<dt><b>

*<JSON\_API\_common\_syntax\>*

</b></dt>
<dd>

Specifies a JSON context item and a path to the context item, using common syntax for the JSON API.

```
<JSON_API_common_syntax> ::= <JSON_context_item>, <JSON_path_specification>
```


<dl>
<dt><b>

*<JSON\_context\_item\>*

</b></dt>
<dd>

Specifies the JSON document to operate on, such as a table column or string. Collections are not supported.



</dd><dt><b>

*<JSON\_path\_specification\>*

</b></dt>
<dd>

Specifies the path to *<JSON\_context\_item\>*.

```
<JSON_path_specification> ::= <JSON_path_mode> <JSON_path_wff>

<JSON_path_mode> ::= STRICT | LAX
```

Depending on the location in the grammar, there are three kinds of JSON path expressions:


<dl>
<dt><b>

Row pattern path expression

</b></dt>
<dd>

Used to produce an SQL/JSON sequence, with one SQL/JSON item for each row of the output table.



</dd><dt><b>

Column pattern path expression

</b></dt>
<dd>

Used to search for the column within the current SQL/JSON item produced by the row pattern.



</dd><dt><b>

Nested columns pattern path expression

</b></dt>
<dd>

Used for unnesting of \(even deeply\) nested JSON objects/arrays in one invocation rather than chaining several JSON\_TABLE expressions in the SQL-statement.



</dd>
</dl>

For example:


<table>
<tr>
<th valign="top">

Path Expression Type

</th>
<th valign="top">

Example Syntax

</th>
</tr>
<tr>
<td valign="top">

Row pattern path expression

</td>
<td valign="top">

'lax $'

</td>
</tr>
<tr>
<td valign="top">

Column pattern path expression

</td>
<td valign="top">

'lax $.name'

'lax $.type'

'lax $.number'

</td>
</tr>
<tr>
<td valign="top">

Nested pattern path expression

</td>
<td valign="top">

'lax $.phoneNumber\[\*\]'

</td>
</tr>
</table>

```
SELECT bookclub.id, jt.name, jt.type, jt.number 
FROM bookclub, 
    JSON_TABLE ( bookclub.jcol, 'lax $'
                 COLUMNS ( name VARCHAR(30) PATH 'lax $.Name', 
                           NESTED PATH 'lax $.phoneNumber[*]'
                              COLUMNS ( type VARCHAR(10) PATH 'lax $.type', 
                                        number CHAR(12) PATH 'lax $.number' ) 
                         )
               ) AS jt;

```

The error types generated by the *<JSON\_path\_specification\>* are:

-   an input conversion error \(for example, invalid JSON document – cannot be parsed\)
-   an error returned by the PATH engine, which evaluates JSON path expressions
-   a structural error meaning no matching path in the JSON document \(for example, ‘$.ab’ path expression against \{“cd” : 1\}\)
    -   If a structural error occurs within a JSON filter expression and *<JSON\_path\_mode\>* is set to STRICT, then the error handling of a JSON filter expression applies. Otherwise, a structural error is an unhandled error.
    -   When the path is set to LAX, one of the following options occurs:
        -   If an operation requires an SQL/JSON array but the operand is not an SQL/JSON array, then the operand is wrapped in an SQL/JSON array prior to performing the operation.
        -   If an operation requires something other than an SQL/JSON array, but the operand is an SQL/JSON array, then the operand is unwrapped by converting its elements into an SQL/JSON sequence prior to performing the operation.

    -   Array indexes start from 0, rather than 1 \(the SQL standard\).
    -   If there is still a structural error after applying these resolutions, then the result is an empty SQL/JSON sequence.


*<JSON\_path\_wff\>* indicates an actual JSON path \(for example, `'$.item1'`\). *<JSON\_path\_specification\>* does not use double quotes.



</dd>
</dl>



</dd><dt><b>

*<JSON\_table\_columns\_clause\>*

</b></dt>
<dd>

Specifies the columns that are created.

```
<JSON_table_columns_clause> ::= 
 COLUMNS ( <JSON_table_column_definition> [,... ] )
 
<JSON_table_column_definition> ::= 
<JSON_table_ordinality_column_definition>
 | <JSON_table_regular_column_definition>
 | <JSON_table_formatted_column_definition>
 | <JSON_table_nested_columns>
```


<dl>
<dt><b>

*<JSON\_table\_column\_definition\>*

</b></dt>
<dd>

Defines the columns generated.



</dd><dt><b>

*<JSON\_table\_ordinality\_column\_definition\>*

</b></dt>
<dd>

Defines an ordinality column. An ordinality column is similar to a column defined using the ROW\_NUMBER window function.

```
<JSON_table_ordinality_column_definition> ::= <column_name> FOR ORDINALITY
```



</dd><dt><b>

*<JSON\_table\_regular\_column\_definition\>*

</b></dt>
<dd>

Defines the regular columns. Each result \(row\) of a regular JSON table column is equivalent to a JSON\_VALUE function result.

```
<JSON_table_regular_column_definition> ::= <column_name> <data_type>
 PATH <JSON_table_column_path_specification> 
 [ <JSON_table_column_empty_behavior> ON EMPTY ]
 [ <JSON_table_column_error_behavior> ON ERROR ]

<JSON_table_column_path_specification> ::= <JSON_path_specification>
 
<JSON_table_column_empty_behavior> ::=
ERROR
 | NULL
 | DEFAULT <value_expression>
 
<JSON_table_column_error_behavior> ::=
ERROR
 | NULL
 | DEFAULT <value_expression>
```


<dl>
<dt><b>

*<column\_name\>*

</b></dt>
<dd>

Specifies the name of the column.



</dd><dt><b>

*<data\_type\>*

</b></dt>
<dd>

Specifies the data type.

```
<data_type> ::= 
BIGINT
 | DATE
 | DECIMAL
 | DOUBLE
 | INT
 | NVARCHAR (<int_const>)
 | SECONDDATE
 | SMALLDECIMAL 
 | TIME
 | TIMESTAMP
```



</dd><dt><b>

*<JSON\_table\_column\_path\_specification\>*

</b></dt>
<dd>

Specifies the JSON path that specifies which JSON value the JSON context item is extracted from.



</dd><dt><b>

*<JSON\_table\_column\_empty\_behavior\>* ON EMPTY

</b></dt>
<dd>

Specifies the behavior of the function when the created column is empty. The default is NULL ON EMPTY.

ERROR ON EMPTY returns an error when the created column is empty. NULL ON EMPTY returns a NULL when the created column is empty. DEFAULT *<value\_expression\>* ON EMPTY returns *<value\_expression\>* when the created column is empty.



</dd><dt><b>

*<JSON\_table\_column\_error\_behavior\>* ON ERROR

</b></dt>
<dd>

Specifies the behavior of the function when there is an error during column creation. The default is NULL ON ERROR.

ERROR ON ERROR results in an error being thrown if the function result includes an error. NULL ON ERROR returns a NULL if the function result includes an error. DEFAULT *<value\_expression\>* ON ERROR returns *<value\_expression\>* if the function result includes an error.



</dd>
</dl>



</dd><dt><b>

*<JSON\_table\_formatted\_column\_definition\>*

</b></dt>
<dd>

Specifies the column definition for formatted columns where the records in the column are formatted in JSON syntax. Each result \(row\) of a regular JSON table column is equivalent to a JSON\_QUERY function result.

```
<JSON_table_formatted_column_definition> ::= 
 <column_name> <data_type>
 FORMAT <JSON_representation>
 PATH <JSON_table_column_path_specification>
 [ <JSON_table_formatted_column_wrapper_behavior> WRAPPER ]
 [ <JSON_table_formatted_column_empty_behavior> ON EMPTY ]
 [ <JSON_table_formatted_column_error_behavior> ON ERROR ]
```



</dd><dt><b>

*<column\_name\>*

</b></dt>
<dd>

Specifies the name of the column.



</dd><dt><b>

*<data\_type\>*

</b></dt>
<dd>

Specifies the data type to be set as the return type of the function. Supported types are: NVARCHAR.



</dd><dt><b>

*<JSON\_representation\>*

</b></dt>
<dd>

Specifies the JSON encoding to use.

```
<JSON_representation> ::=
JSON
 | JSON ENCODING { UTF8 }
 | JSON ENCODING { UTF16 }
 | JSON ENCODING { UTF32 }
```



</dd><dt><b>

*<JSON\_table\_column\_path\_specification\>*

</b></dt>
<dd>

Specifies the JSON path that specifies which JSON value the JSON context item is extracted from.



</dd><dt><b>

*<JSON\_table\_formatted\_column\_wrapper\_behavior\>* WRAPPER

</b></dt>
<dd>

Specifies the wrapper behavior of the formatted column.

```
<JSON_table_formatted_column_wrapper_behavior> ::=
WITHOUT [ ARRAY ]
 | WITH [ CONDITIONAL | UNCONDITIONAL ] [ ARRAY ]
```

When WITHOUT \[ ARRAY \] WRAPPER is specified, the formatted column is not represented as a JSON array. When WITH \[ CONDITIONAL | UNCONDITIONAL \] \[ ARRAY \] WRAPPER is specified, the formatted column is set with a conditional/unconditional array. With a conditional array, the result is formatted as a JSON array if the result is neither a JSON array nor a JSON object. With an unconditional array, the result is formatted as a JSON array if the result is not a JSON object. The difference between unconditional and conditional wrapper is that unconditional wrapper wraps the result as a JSON array once more when the result is a JSON array.



</dd><dt><b>

*<JSON\_table\_formatted\_column\_empty\_behavior\>* ON EMPTY

</b></dt>
<dd>

Specifies the JSON behavior if the related data is not in the context item.

```
<JSON_table_formatted_column_empty_behavior> ::=
ERROR
 | NULL
 | EMPTY ARRAY
 | EMPTY OBJECT
```

ERROR ON EMPTY returns an error if the related data is not in the context item. NULL ON EMPTY returns a NULL if the related data is not in the context item. EMPTY ARRAY ON EMPTY returns an empty array if the related data is not in the context item. EMPTY OBJECT ON EMPTY returns an empty JSON object if the related data is not in the context item.



</dd><dt><b>

*<JSON\_table\_formatted\_column\_error\_behavior\>* ON ERROR

</b></dt>
<dd>

Specifies the behavior when the formatted column throws an error.

```
<JSON_table_formatted_column_error_behavior> ::=
ERROR
 | NULL
 | EMPTY ARRAY
 | EMPTY OBJECT
```

ERROR ON ERROR returns an error if the function returns no result. NULL ON ERROR returns a NULL if the function returns no result. EMPTY ARRAY ON ERROR returns an empty array if the result of the formatted column is empty. EMPTY OBJECT ON ERROR returns an empty JSON object if the result of the formatted column is empty.



</dd><dt><b>

*<JSON\_table\_nested\_columns\>*

</b></dt>
<dd>

Defines nested columns.

```
<JSON_table_nested_columns> ::= NESTED [ PATH ] <JSON_table_nested_path_specification>
 <JSON_table_columns_clause>

<JSON_table_nested_path_specification> ::= <JSON_path_specification>
```

-   *<JSON\_table\_columns\_clause\>*: Specifies the columns that are created with the function.

-   *<JSON\_path\_specification\>*: The JSON path which specifies which JSON value from the JSON context item is extracted.




</dd>
</dl>



</dd><dt><b>

*<JSON\_table\_error\_behavior\>*

</b></dt>
<dd>

Specifies the behavior of the function when an error occurs. The default behavior is EMPTY ON ERROR.

```
<JSON_table_error_behavior> ::= { ERROR | EMPTY }
```


<dl>
<dt><b>

ERROR

</b></dt>
<dd>

If the function result includes an error, then the error is returned.



</dd><dt><b>

EMPTY

</b></dt>
<dd>

If the function result includes an error, then it returns an empty result.



</dd>
</dl>



</dd>
</dl>



<a name="loiof8f6916b5c434a6fbd1bb7e0dc65acd4__json_table_function_1sql_json_table_function_description"/>

## Description

Queries a JSON text and presents it as a relational table.

All of the errors and empty handling that results from column pattern path expression evaluation, as well as output conversion errors are handled by *<JSON\_table\_column\_empty\_behavior\>*, *<JSON\_table\_column\_error\_behavior\>*, *<JSON\_table\_formatted\_column\_empty\_behavior\>* ON EMPTY, and *<JSON\_table\_formatted\_column\_error\_behavior\>* ON ERROR.

All of the errors resulting from row pattern expression evaluation and nested columns pattern path expression evaluation are handled by *<JSON\_table\_error behavior\>*.

The following tokens are supported in *<JSON\_API\_common\_syntax\>*:


<table>
<tr>
<th valign="top">

Token

</th>
<th valign="top">

Description

</th>
<th valign="top">

Example

</th>
</tr>
<tr>
<td valign="top">

$

</td>
<td valign="top">

The current context item.

</td>
<td valign="top">

`'$'` 

</td>
</tr>
<tr>
<td valign="top">

.

</td>
<td valign="top">

The member of an object.

</td>
<td valign="top">

`'$.item.description'` 

</td>
</tr>
<tr>
<td valign="top">

\[

</td>
<td valign="top">

The array index specifier \(open\).

</td>
<td valign="top">



</td>
</tr>
<tr>
<td valign="top">

\]

</td>
<td valign="top">

The array index specifier \(closed\).

</td>
<td valign="top">

`'$[1]'`

`'$.item.list[1]'`

</td>
</tr>
<tr>
<td valign="top">

to

</td>
<td valign="top">

The array index range.

</td>
<td valign="top">

`'$[3 to 5]'`

`= '$[3,4,5]'`

</td>
</tr>
<tr>
<td valign="top">

\*

</td>
<td valign="top">

The wild card.

</td>
<td valign="top">

`'$.*.description'`

`'$.item.list[*]'`

</td>
</tr>
</table>



<a name="loiof8f6916b5c434a6fbd1bb7e0dc65acd4__json_table_function_1sql_function_map_examples"/>

## Example

The following examples use the table created below:

```
CREATE ROW TABLE T1 (A INT, B NVARCHAR(5000));
INSERT INTO T1 VALUES (1, '
{
        "PONumber": 1,
        "Reference": "BSMITH-74635645",
        "Requestor": "Barb Smith",
        "User": "BSMITH",
        "CostCenter": "A50",
        "ShippingInstructions":
               {
                       "name": "Barb Smith",
                       "Address":
                               {
                                      "street": "100 Fairchild Ave",
                                      "city": "San Diego",
                                       "state": "CA",
                                      "zipCode": 23345,
                                      "country": "USA"
                               },
                       "Phone": [{"type": "Office", "number": "519-555-6310"}]
               },
        "SpecialInstructions": "Surface Mail",
        "LineItems": [
               {"ItemNumber": 1, "Part": {"Description": "Basic Kit", "UnitPrice": 19.95, "UPCCode": 73649587162}, "Quantity": 7},
               {"ItemNumber": 2, "Part": {"Description": "Base Kit 2", "UnitPrice": 29.95, "UPCCode": 83600229374}, "Quantity": 1},
               {"ItemNumber": 3, "Part": {"Description": "Professional", "UnitPrice": 39.95, "UPCCode": 33298003521}, "Quantity": 8},
               {"ItemNumber": 4, "Part": {"Description": "Enterprise", "UnitPrice": 49.95, "UPCCode": 91827739856}, "Quantity": 8},
               {"ItemNumber": 5, "Part": {"Description": "Unlimited", "UnitPrice": 59.95, "UPCCode": 22983303876}, "Quantity": 8}
        ]
}
');
```

The following example selects from an ordinality column and a regular column:

```
SELECT JT.*
FROM JSON_TABLE(T1.B, '$.LineItems[*]'
COLUMNS
    (
        RN FOR ORDINALITY,
        ITEM_NUMBER INT PATH '$.ItemNumber',
        UPC_CODE BIGINT PATH '$.Part.UPCCode'
    )
) AS JT;
```


<table>
<tr>
<th valign="top">

RN

</th>
<th valign="top">

ITEM\_NUMBER

</th>
<th valign="top">

UPC\_CODE

</th>
</tr>
<tr>
<td valign="top">

1

</td>
<td valign="top">

1

</td>
<td valign="top">

73649587162

</td>
</tr>
<tr>
<td valign="top">

2

</td>
<td valign="top">

2

</td>
<td valign="top">

83600229374

</td>
</tr>
<tr>
<td valign="top">

3

</td>
<td valign="top">

3

</td>
<td valign="top">

33298003521

</td>
</tr>
<tr>
<td valign="top">

4

</td>
<td valign="top">

4

</td>
<td valign="top">

91827739856

</td>
</tr>
<tr>
<td valign="top">

5

</td>
<td valign="top">

5

</td>
<td valign="top">

22983303876

</td>
</tr>
</table>

The following example selects from a formatted column:

```
SELECT *
FROM JSON_TABLE(T1.B, '$.ShippingInstructions'
COLUMNS
    (
        PHONE NVARCHAR(50) FORMAT JSON PATH '$.Phone'
    )
) AS JT;
```


<table>
<tr>
<th valign="top">

PHONE

</th>
</tr>
<tr>
<td valign="top">

\[\{"number":"519-555-6310","type":"Office"\}\]

</td>
</tr>
</table>

The following example selects from a nested column:

```
SELECT *
FROM JSON_TABLE(T1.B, '$.ShippingInstructions'
COLUMNS
    (
        NESTED PATH '$.Address'
        COLUMNS
        (
            STREET NVARCHAR(50) PATH '$.street',
            CITY NVARCHAR(50) PATH '$.city'
        )
    )
) AS JT;
```


<table>
<tr>
<th valign="top">

STREET

</th>
<th valign="top">

CITY

</th>
</tr>
<tr>
<td valign="top">

100 Fairchild Ave

</td>
<td valign="top">

San Diego

</td>
</tr>
</table>

The following example selects from an ordinality column with nested columns:

```
SELECT *
FROM JSON_TABLE(T1.B, '$'
    COLUMNS
    (
        RN FOR ORDINALITY,
        USER_NAME NVARCHAR(20) PATH '$.User',
        NESTED PATH '$.LineItems[1,2]'
        COLUMNS
        (
            ORDER_NUMBER FOR ORDINALITY,
            ITEM_NUMBER INT PATH '$.ItemNumber',
            QUANTITY INT PATH '$.Quantity'
        )
    )
) AS JT;
```


<table>
<tr>
<th valign="top">

RN

</th>
<th valign="top">

USER\_NAME

</th>
<th valign="top">

ORDER\_NUMBER

</th>
<th valign="top">

ITEM\_NUMBER

</th>
<th valign="top">

QUANTITY

</th>
</tr>
<tr>
<td valign="top">

1

</td>
<td valign="top">

BSMITH

</td>
<td valign="top">

1

</td>
<td valign="top">

2

</td>
<td valign="top">

1

</td>
</tr>
<tr>
<td valign="top">

1

</td>
<td valign="top">

BSMITH

</td>
<td valign="top">

2

</td>
<td valign="top">

3

</td>
<td valign="top">

8

</td>
</tr>
</table>

The following example demonstrates the difference when specifying CONDITIONAL ARRAY WRAPPER versus UNCONDITIONAL ARRAY WRAPPER when returning a JSON array:

```
CREATE ROW TABLE r1 ( a INT, b NVARCHAR(5000));
INSERT INTO r1 VALUES (1, '{"menu": {"header": "SVG Viewer","items": [{"id": "Open"},{"id": "OpenNew", "label": "Open New"},null,{"id": "ZoomIn", "label": "Zoom In"}]}}');

```


<table>
<tr>
<th valign="top">

SELECT statement

</th>
<th valign="top">

Value returned

</th>
</tr>
<tr>
<td valign="top">

```
SELECT JSON_QUERY(B, '$.menu.items' 
   WITH UNCONDITIONAL ARRAY WRAPPER) 
 FROM r1 WITH HINT(IGNORE_PLAN_CACHE);
```



</td>
<td valign="top">

```
[[{"id":"Open"},{"id":"OpenNew","label":"Open New"},null,{"id":"ZoomIn","label":"Zoom In"}]]
```



</td>
</tr>
<tr>
<td valign="top">

```
SELECT JSON_QUERY(B, '$.menu.items' 
   WITH CONDITIONAL ARRAY WRAPPER) 
FROM r1;
```



</td>
<td valign="top">

```
[{"id":"Open"},{"id":"OpenNew","label":"Open New"},null,{"id":"ZoomIn","label":"Zoom In"}]
```



</td>
</tr>
</table>

The following example demonstrates an example of ERROR ON ERROR, which results in an error stating that the data for '$.User' cannot be parsed to an integer data type.

```
SELECT *
FROM JSON_TABLE(T1.B, '$'
    COLUMNS
    (
        RN FOR ORDINALITY,
        USER_NAME INT PATH '$.User' ERROR ON ERROR
    )
ERROR ON ERROR
) AS JT;

```

The following example demonstrates an example of EMPTY ON ERROR. The default behavior of JSON\_table\_error\_behavior is EMPTY ON ERROR. It returns an error result instead of throwing empty when JSON\_table\_column\_error\_behavior is ERROR ON ERROR or JSON\_table\_column\_empty\_behavior is ERROR ON EMPTY.

```
SELECT *
FROM JSON_TABLE(T1.B, '$'
    COLUMNS
    (
        RN FOR ORDINALITY,
        USER_NAME INT PATH '$.User' ERROR ON ERROR
    )
) AS JT;

```

**Related Information**  


[Expressions](../expressions-20a4389.md "An expression is a clause that can be evaluated to return values.")

