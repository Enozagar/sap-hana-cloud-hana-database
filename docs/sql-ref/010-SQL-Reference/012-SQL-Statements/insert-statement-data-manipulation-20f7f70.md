<!-- loio20f7f70975191014a76da70c9181720e -->

# INSERT Statement \(Data Manipulation\)

Adds a record to a table.



<a name="loio20f7f70975191014a76da70c9181720e__sql_insert_1sql_insert_syntax"/>

## Syntax

```
INSERT INTO <table_name> [ PARTITION <num> ]
 [ [ AS ] <table_alias> ]
 [ ( <column_list_clause> ) ]
 { { <value_list_clause> | [ <overriding_clause> ] <subquery> } | <with_clause> }
 [ <hint_clause> ] [ { <hint_clause> | WITH NOWAIT } ]
```



<a name="loio20f7f70975191014a76da70c9181720e__sql_insert_1sql_insert_syntax_elements2"/>

## Syntax Elements


<dl>
<dt><b>

*<table\_name\>*

</b></dt>
<dd>

Specifies the table or view where the insert is to be performed, with an optional schema name.

```
<table_name> ::= [ [ <database_name>.]<schema_name>.]<identifier>
```

For views, they must reference only a single table and should not include a GROUP BY clause.

For linked databases, *<database\_name\>* is the name of the remote source. *<identifier\>* is the name of the table on the remote source.



</dd><dt><b>

PARTITION *<num\>*

</b></dt>
<dd>

Specifies the partition number where the values are being inserted.



</dd><dt><b>

*<table\_alias\>*

</b></dt>
<dd>

Specifies an alias for the table that can be referenced later in the statement.

If you specify *<table\_alias\>* without using the AS keyword, then you must specify a *<column\_list\_clause\>* that uses the *<table\_alias\>* in each column definition.



</dd><dt><b>

*<column\_list\_clause\>*

</b></dt>
<dd>

Specifies a list of column identifiers, ordered in the order of values in the *<value\_list\_clause\>* or *<subquery\>*.

```
<column_list_clause> ::= ( <column_def> [, <column_def> [,…] ] )           

<column_def> ::= 
 [ [ <schema_name>.]<table_name>.]<column_name>
 | [ <table_alias>.]<column_name>

<schema_name> ::= <identifier>
<table_name> ::= <identifier>
<column_name> ::= <identifier>
```

If the column list is omitted, then the database performs the insert using all the columns in the table. A column that is not included in the column list is filled using the column's default value. When altering a table, always specify the column names to avoid potential issues where the order of the columns has changed.



</dd><dt><b>

*<value\_list\_clause\>*

</b></dt>
<dd>

Specifies a list of values, or expressions evaluating to values, that are inserted into the table.

```
<value_list_clause> ::=
 VALUES ( <expression> [, <expression> [,…] ] )
 [ AS <alias_name> ]
```



</dd><dt><b>

*<subquery\>*

</b></dt>
<dd>

Specifies a subquery. For more information about subqueries, see the SELECT statement.



</dd><dt><b>

*<overriding\_clause\>*

</b></dt>
<dd>

Specifies the override behavior.

```
<overriding_clause> ::= OVERRIDING { SYSTEM | USER } VALUE
```

Use this clause with *<subquery\>*, and only when the table being inserted into has an identity column. You can force the system to use the generated sequence value for identity column by specifying OVERRIDING USER VALUE, and to ignore the value provided from the SELECT.

OVERRIDING USER VALUE is required if the identity column was defined as GENERATED ALWAYS clause, and it is optional if the column was defined as GENERATED BY DEFAULT.

If OVERRIDING USER VALUE is not specified for a GENERATED BY DEFAULT identity column, the value provided for the column in the SELECT is inserted.

OVERRIDING SYSTEM VALUE tells the system to use the value from the select for an identity column.



</dd><dt><b>

*<with\_clause\>*

</b></dt>
<dd>

Defines the columns and the data to insert into them.

```
<with_clause> ::= WITH <alias> AS ( <subquery> ) SELECT <expression> FROM <alias>
```



</dd><dt><b>

*<hint\_clause\>*

</b></dt>
<dd>

For information on hints, see the HINT clause of the SELECT statement.



</dd><dt><b>

WITH NOWAIT

</b></dt>
<dd>

Generates an immediate error if the INSERT statement writes a row that already exists and is locked.

The WITH NOWAIT clause supports:

-   column table
-   partitioned column table
-   projection view on column table
-   system-versioned table
-   INSERT operator

WITH NOWAIT does not support:

-   row table
-   application-app-time table
-   temporary table
-   virtual table
-   UPDATE, DELETE, REPLACE, or MERGE-INTO operators
-   INSERT inside a trigger or foreign key in a cascaded manner
-   Cascade to a trigger or a foreign key



</dd>
</dl>



<a name="loio20f7f70975191014a76da70c9181720e__sql_insert_1sql_insert_description"/>

## Description

The values to be inserted can either be values, expressions, or the result of a subquery. If the subquery used does not return any records, then the database does not insert any records into the table.

Always define the *<column\_list\_clause\>*. This practice helps to protect your INSERT queries from damaging data if the target table schema is modified.



<a name="loio20f7f70975191014a76da70c9181720e__sql_insert_1sql_insert_examples"/>

## Examples

Create table T:

```
CREATE TABLE T (KEY INT PRIMARY KEY, VAL1 INT, VAL2 NVARCHAR(20));
```

Insert a row into table T.

```
INSERT INTO T VALUES (1, 1, 'The first');
```


<table>
<tr>
<td valign="top">

KEY

</td>
<td valign="top">

VAL1

</td>
<td valign="top">

VAL2

</td>
</tr>
<tr>
<td valign="top">

1

</td>
<td valign="top">

1

</td>
<td valign="top">

The first

</td>
</tr>
</table>

Insert a new row into table T using column list to specify which columns should receive the input values.

```
INSERT INTO T (KEY, VAL2) VALUES (2,3);
```


<table>
<tr>
<td valign="top">

KEY

</td>
<td valign="top">

VAL1

</td>
<td valign="top">

VAL2

</td>
</tr>
<tr>
<td valign="top">

1

</td>
<td valign="top">

1

</td>
<td valign="top">

The first

</td>
</tr>
<tr>
<td valign="top">

2

</td>
<td valign="top">

0

</td>
<td valign="top">

NULL

</td>
</tr>
</table>

Insert a row into table T using a subquery.

```
INSERT INTO T SELECT 3, 3, 'The third' FROM DUMMY;
```


<table>
<tr>
<td valign="top">

KEY

</td>
<td valign="top">

VAL1

</td>
<td valign="top">

VAL2

</td>
</tr>
<tr>
<td valign="top">

1

</td>
<td valign="top">

1

</td>
<td valign="top">

The first

</td>
</tr>
<tr>
<td valign="top">

2

</td>
<td valign="top">

0

</td>
<td valign="top">

3

</td>
</tr>
<tr>
<td valign="top">

3

</td>
<td valign="top">

3

</td>
<td valign="top">

The third

</td>
</tr>
</table>

Insert values into an array value construction by enumeration.

```
INSERT INTO T1 VALUES ( 1, ARRAY ( 1, 2, 3, 4 ) );
```

Insert values into an array value construction by query.

```
CREATE TABLE T0 ( C1 INT )
   INSERT INTO T0 VALUES ( 21 )
   INSERT INTO T0 VALUES ( 22 )
   INSERT INTO T0 VALUES ( 23 )
   INSERT INTO T1 VALUES ( 2, ARRAY( SELECT C1 FROM T0 ) )
```

Insert a NULL value into an ARRAY.

```
INSERT INTO T1 (ID) VALUES (3);
```

Use an alias for the table you are inserting values into.

```
INSERT INTO CXML_LOG_CONTENT AS t0 (t0.IS_COMPRESSED, CONTENT, t0.CONTENT_KEY, t0.CONTENT_NEED_ENCR, t0.CONTENT_SIZE, ID)  
   VALUES ('true', EMPTY_BLOB(), NULL, '0', '333', '1234');
```

In the example below, the latter two INSERT statements demonstration inserting data into a table using the WITH clause:

```
CREATE TABLE t1(a INT, b INT, c INT);  
CREATE TABLE t2(a INT, b INT, c INT);
INSERT INTO t1 VALUES(1,12,13);            
INSERT INTO t2 VALUES(2,120,130);
            
INSERT INTO t1 WITH alias AS (SELECT * FROM t1) SELECT * FROM alias;
INSERT INTO t1 WITH w1 AS (SELECT * FROM t2) SELECT * FROM w1;
```

Use the alias t0 for the CXML\_LOG\_CONTENT table.

```
INSERT INTO CXML_LOG_CONTENT AS t0 (t0.IS_COMPRESSED, CONTENT, t0.CONTENT_KEY, t0.CONTENT_NEED_ENCR, t0.CONTENT_SIZE, ID)
   VALUES ('true', EMPTY_BLOB(), NULL, '0', '333', '1234');
```

In the example below, the first statement inserts values into table T using the *<table\_name.column\_name\>* column definition. The second statement inserts values into the table named ALIAS\_T using the *<table\_alias.column\_name\>* column definition.

```
INSERT INTO T (T.KEY, T.VAL2) VALUES(2,3);
INSERT INTO T ALIAS_T (ALIAS_T.KEY, ALIAS_T.VAL2) VALUES(2,3);
```

This example demonstrates the use of the WITH NOWAIT clause. create table A1 \(a int primary key, b int\);

```
INSERT INTO T1 VALUES (1,1);
COMMIT;
```

Using connection1, with autocommit off, execute:

```
SELECT * FROM T1 WHEREB=1 FOR UPDATE;
```

This statement is held because of a rowlock from the \(1, 1\) insertion.

Using connection2, execute:

```
INSERT INTO T1 VALUES (1, 10) WITH NOWAIT;
```

This statement immediately returns an error without waiting for the release of the rowlock for the \(1, 1\) insertion.

**Related Information**  


[Introduction to SQL](../introduction-to-sql-209f502.md "This chapter describes the SAP HANA database implementation of Structured Query Language (SQL).")

[Expressions](../expressions-20a4389.md "An expression is a clause that can be evaluated to return values.")

[Predicates](../predicates-20a2ab2.md "")

[SELECT Statement \(Data Manipulation\)](select-statement-data-manipulation-20fcf24.md "Queries data from the database.")

